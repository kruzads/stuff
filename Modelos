
#PACOTES EM USO
library(nimble, warn.conflicts = FALSE)
library(MCMCvis)
library(readxl)


#EQUIPAS PARTICIPANTES NA TEMPORADA 2014-2015
lista_equipas <- c("Académica","Arouca","Belenenses","Benfica","Boavista","Braga","Estoril","FC Porto", "Gil Vicente","Marítimo","Moreirense","Nacional","Paços Ferreira",
                   "Penafiel","Rio Ave", "Sporting","Vitória FC","Vitória SC")

# DADOS (SÓ SE USA A 1ª TEMPORADA)
liga14_20<-liga14_20[1:306,]

# O MODELO É DEFINIDO AQUI DENTRO
futebolCode <- nimbleCode({
  
  # LIKELIHOOD AND RANDOM EFFECT MODEL FOR THE SCORING PROPENSITY (COMUM A TODOS OS MODELOS DE GOLOS)
  for (g in 1:ngames) {
    # Observed number of goals scored by each team
    y1[g] ~ dpois(theta[g,1])
    y2[g] ~ dpois(theta[g,2])
    # Average Scoring intensities (accounting for mixing components)
    log(theta[g,1]) <-  home + att[hometeam[g]] + def[awayteam[g]] #golos marcados pela equipa de casa
    log(theta[g,2]) <-  att[awayteam[g]] + def[hometeam[g]]        #golos marcados pela equipa de fora
  }

  
# 1. BASIC MODEL FOR THE HYPERPARAMETERS (ESPECIFICO AO MODELO DE POISSON)
# prior on the home effect
home ~ dnorm(0,0.0001)
# Trick to code the ''sum-to-zero'' constraint
for (t in 1:nteams){
  att.star[t] ~ dnorm(mu.att,tau.att)
  def.star[t] ~ dnorm(mu.def,tau.def)
  att[t] <- att.star[t] - mean(att.star[1:nteams])
  def[t] <- def.star[t] - mean(def.star[1:nteams])
}

# priors on the random effects
mu.att ~ dnorm(0,0.001)
mu.def ~ dnorm(0,0.001)
tau.att ~ dgamma(0.01,0.01)
tau.def ~ dgamma(0.01,0.01)

})


# 2. MIXTURE MODEL FOR THE HYPERPARAMETERS (ESPECIFICO AO MODELO DE MISTURA DE PARÂMETROS)
# prior on the home effect
home ~ dnorm(0,0.0001)
# Mixture parameters & components (''sum-to-zero'' constraint)
for (t in 1:nteams){
  grp.att[t] ~ dcat(p.att[t,1:3])
  grp.def[t] ~ dcat(p.def[t,1:3])
  att[t] ~ dt(mu.att[grp.att[t]],tau.att[grp.att[t]],4)
  def[t] ~ dt(mu.def[grp.def[t]],tau.def[grp.def[t]],4)
  att.star[t] <- att[t] - mean(att[1:nteams])
  def.star[t] <- def[t] - mean(def[1:nteams])
  # Priors on the mixture parameter (team specific)
  p.att[t,1:3] ~ ddirch(prior.att[t,1:3])
  p.def[t,1:3] ~ ddirch(prior.def[t,1:3])
}
# Priors on the random effects
# group 1: bottom-table teams
mu.att[1] ~ T(dnorm(0,0.001),-3,0)
mu.def[1] ~ T(dnorm(0,0.001),0,3)
tau.att[1] ~ dgamma(0.01,0.01)
tau.def[1] ~ dgamma(0.01,0.01)
# group 2: mid-table teams
mu.att[2] <-0
mu.def[2] <-0
tau.att[2] ~ dgamma(0.01,0.01)
tau.def[2] ~ dgamma(0.01,0.01)
# group 3: top-table teams
mu.att[3] ~ T(dnorm(0,0.001),0,3)
mu.def[3] ~ T(dnorm(0,0.001),-3,0)
tau.att[3] ~ dgamma(0.01,0.01)
tau.def[3] ~ dgamma(0.01,0.01)
})

#CONSTANTES DO MODELO (Nº JOGOS, Nº EQUIPAS, LOCALIZAÇÃO DOS INDICES E TEMPORADA)
futebolConsts <- list(ngames = 306, nteams = 18, hometeam=liga14_20$h_g, awayteam=liga14_20$a_g, season=liga14_20$Temporada)

#DADOS DOS GOLOS MARCADOS
futebolData <- list(y1 = liga14_20$y_g1, y2=liga14_20$y_g2)



#VALORES INICIAIS PARA OS PARÂMETROS DO MODELO DE POISSON (1 CADEIA)
# futebolInits <- list(home = 0, mu.att = 0, mu.def = 0, tau.att = 1, tau.def = 1, theta = matrix(1,306,2), att.star = rep(1,18), def.star = rep(1,18))


#VALORES INICIAIS PARA OS PARÂMETROS DO MODELO DE POISSON (3 CADEIAS COM VALORES INICIAIS DIFERENTES)
futebolInits <- list(list(home = 0, mu.att = 0, mu.def = 0, tau.att = 1, tau.def = 1, theta = matrix(1,306,2), att.star = rep(1,18), def.star = rep(1,18)),
                list(home = -0.9, mu.att = -0.6, mu.def = -0.6, tau.att = 0.6, tau.def = 0.6, theta = matrix(2,306,2), att.star = rep(0,18), def.star = rep(0,18)),
                list(home = 1, mu.att = 1, mu.def = 1, tau.att = 0.001, tau.def = 0.001, theta = matrix(5,306,2), att.star = rep(0.4,18), def.star = rep(0.4,18)))


#VALORES INICIAIS PARA OS PARÂMETROS DO MODELO DE MISTURA DOS HYPERPARÂMETROS (3 CADEIAS COM VALORES INICIAIS DIFERENTES) 
futebolInits <- list(list(home = 0 , mu.att = rep(0,3), mu.def = rep(0,3), tau.att = rep(1,3), tau.def = rep(1,3), theta = matrix(1,306,2),
                          p.att = matrix(1/3,18,3), p.def = matrix(1/3,18,3), grp.att = rep(1,18), grp.def = rep(1,18), att = rep(1,18), def = rep(1,18), 
                          prior.att = matrix(1/3,18,3), prior.def = matrix(1/3,18,3)),
                     list(home = -0.9, mu.att = c(-3,0,3), mu.def = c(3,0,-3),tau.att = rep(0.6,3), tau.def = rep(0.6,3), theta = matrix(2,306,2), 
                          p.att = matrix(1/3,18,3), p.def = matrix(1/3,18,3), grp.att = rep(2,18), grp.def = rep(2,18), att = rep(2,18), def = rep(2,18),
                          prior.att = matrix(0.2,18,3), prior.def = matrix(0.2,18,3)),
                     list(home = 10, mu.att = c(-1,0,1), mu.def = c(1,0,-1),tau.att = rep(0.001,3), tau.def = rep(0.001,3), theta = matrix(5,306,2), 
                          p.att = matrix(1/3,18,3), p.def = matrix(1/3,18,3), grp.att = rep(3,18), grp.def = rep(3,18), att = rep(0.4,18), def = rep(0.4,18),
                          prior.att = matrix(1,18,3), prior.def = matrix(1,18,3)))


futebolInits <- list(home = 0 , mu.att = rep(0,3), mu.def = rep(0,3), tau.att = rep(1,3), tau.def = rep(1,3),
                     theta = matrix(1,306,2), p.att = matrix(1/3,18,3), p.def = matrix(1/3,18,3),
                     grp.att = rep(1,18), grp.def = rep(1,18), att = rep(1,18), def = rep(1,18),
                     prior.att = matrix(1/3,18,3), prior.def = matrix(1/3,18,3))


#PARÂMETROS PARA GUARDAR
futebolMonitor <- c("theta","att","home","def")  #POISSON
futebolMonitor <- c("theta","att","home","def","grp.att","grp.def") #MISTURA

#EXECUTA O MCMC
nimbleMCMC_fut <- nimbleMCMC(code = futebolCode, constants = futebolConsts, inits= futebolInits,data = futebolData, monitors = futebolMonitor, niter = 100000, 
                             nburnin = 50000, thin=10, nchains=3, samplesAsCodaMCMC=TRUE, WAIC = TRUE)
                             
                             
#############################################################################################################################################################################
######################################################################## MODELO MULTINOMIAL #################################################################################
                             

futebolCode_m <- nimbleCode({
  
  for(g in 1:ngames){
    y[g,1:3] ~ dmulti(theta[g,1:3], 1)

    for(k in 1:3){
      theta[g,k] <- phi[g,k] / sum(phi[g,1:3]) #probabilidade do resultado k(vitoria casa/fora/empate) para o jogo g
    }

    log(phi[g,1]) <- home + att[hometeam[g]] + def[awayteam[g]] #resultado ser vitoria casa
    log(phi[g,2]) <- att[awayteam[g]] + def[hometeam[g]]        #resultado ser vitoria fora
    phi[g,3] ~ dunif(0.001,10)                                  #resultado ser empatE
  }
 
  # 1. BASIC MODEL FOR THE HYPERPARAMETERS
  # prior on the home effect
  home ~ dnorm(0,0.0001)
  # Trick to code the ''sum-to-zero'' constraint
  for (t in 1:nteams){
    att.star[t] ~ dnorm(mu.att,tau.att)
    def.star[t] ~ dnorm(mu.def,tau.def)
    att[t] <- att.star[t] - mean(att.star[1:nteams])
    def[t] <- def.star[t] - mean(def.star[1:nteams])
  }

  # priors on the random effects
  mu.att ~ dnorm(0,0.001)
  mu.def ~ dnorm(0,0.001)
  tau.att ~ dgamma(0.01,0.01)
  tau.def ~ dgamma(0.01,0.01)
})


#dados do índice para a equipa de fora e da casa e o número de golos marcado por cada
futebolConsts_m <- list(ngames = 306, nteams = 18, hometeam = liga14_20$h_g, awayteam = liga14_20$a_g)
futebolData_m <- list(y=as.matrix(cbind(liga14_20$Vitoria_casa,liga14_20$Vitoria_fora,liga14_20$Empate)))

futebolInits_m <- list(home = 0, mu.att = 0, mu.def = 0, tau.att = 1, tau.def = 1, phi=matrix(1/3,306,3), att.star = rep(1,18), def.star = rep(1,18))


futebolInits_m <- list(list(home = 0, mu.att = 0, mu.def = 0, tau.att = 1, tau.def = 1, phi=matrix(1/3,306,3), att.star = rep(1,18), def.star = rep(1,18)),
                       list(home = -2, mu.att = 1, mu.def = 1, tau.att = 3, tau.def = 3, phi=matrix(1/2,306,3), att.star = rep(0.2,18), def.star = rep(0.2,18)),
                       list(home = 10, mu.att = 2, mu.def = 2, tau.att = 0.3, tau.def = 0.3, phi=matrix(1/4,306,3), att.star = rep(4,18), def.star = rep(4,18)))

futebolMonitor_m <- c("theta","phi","home","att","def")


start.time <- Sys.time() 

nimbleMCMC_fut_m <- nimbleMCMC(code = futebolCode_m, constants = futebolConsts_m, inits= futebolInits_m, data = futebolData_m, monitors = futebolMonitor_m, 
                               niter = 100000, nburnin = 50000, nchains = 3, thin = 10, samplesAsCodaMCMC = TRUE, WAIC = TRUE)

end.time <- Sys.time()

#CALCULA O TEMPO DE EXECUÇÃO DE EXECUÇÃO DO MCMC
time.taken <- end.time - start.time
time.taken

#############################################################################################################################################################################
################################################################# MODELO POISSON INFLACIONADA DE ZEROS ######################################################################
    

#DEFINE A DISTRIBUIÇÃO PARA PODER SER USADA
dZIP <- nimbleFunction(
  run = function(x = integer(), lambda = double(0), zeroProb = double(), log = logical(0, default = 0)) {
    returnType(double())
    ## First handle non-zero data
    if (x != 0) {
      ## return the log probability if log = TRUE
      if (log) return(dpois(x, lambda, log = TRUE) + log(1 - zeroProb))
      ## or the probability if log = FALSE
      else return((1 - zeroProb) * dpois(x, lambda, log = FALSE))
    }
    ## From here down we know x is 0
    totalProbZero <- zeroProb + (1 - zeroProb) * dpois(0, lambda, log = FALSE)
    if (log) return(log(totalProbZero))
    return(totalProbZero)
  })

#Random ZIP - gera amostras aleatorias segundo esta distribuiçao
rZIP <- nimbleFunction(
  run = function(n = integer(), lambda = double(0), zeroProb = double()) {
    returnType(integer())
    isStructuralZero <- rbinom(1, prob = zeroProb, size = 1)
    if (isStructuralZero) return(0)
    return(rpois(1, lambda))
  })

#regista as funções no nimble (dzip e rzip)
registerDistributions(list(
  dZIP = list(
    BUGSdist = "dZIP(lambda, zeroProb)",
    discrete = TRUE,
    range = c(0, Inf),
    types = c('value = integer()', 'lambda = double(0)', 'zeroProb = double()')
  )))

                             
futebolCode <- nimbleCode({
  
  # LIKELIHOOD AND RANDOM EFFECT MODEL FOR THE SCORING PROPENSITY
  for (g in 1:ngames) {
    # Observed number of goals scored by each team
    y1[g] ~ dZIP(lambda1[g], zeroProb=p1 ) #p1 - probabilidade de zeros adicionais para a equipa de casa
    y2[g] ~ dZIP(lambda2[g], zeroProb=p2 ) #p2 - probabilidade de zeros adicionais para a equipa de fora
    # Average Scoring intensities (accounting for mixing components)
    log(lambda1[g]) <- home + att[hometeam[g]] + def[awayteam[g]] #golos marcados pela equipa de casa
    log(lambda2[g]) <- att[awayteam[g]] + def[hometeam[g]]        #golos marcados pela equipa de fora
  }

  # 1. BASIC MODEL FOR THE HYPERPARAMETERS
  # prior on the home effect
  home ~ dnorm(0,0.0001)
  p1 ~ dunif(0,1)
  p2 ~ dunif(0,1)
  
  # Trick to code the ''sum-to-zero'' constraint
  for (t in 1:nteams){
    #home[t] ~ dnorm(0,0.0001)
    att.star[t] ~ dnorm(mu.att,tau.att)
    def.star[t] ~ dnorm(mu.def,tau.def)
    att[t] <- att.star[t] - mean(att.star[1:nteams])
    def[t] <- def.star[t] - mean(def.star[1:nteams])
  }
  
  # priors on the random effects
  mu.att ~ dnorm(0,0.001)
  mu.def ~ dnorm(0,0.001)
  tau.att ~ dgamma(0.01,0.01)
  tau.def ~ dgamma(0.01,0.01)
  
})

#constantes
futebolConsts <- list(ngames = 306, nteams = 18, hometeam=liga14_20$h_g, awayteam=liga14_20$a_g)


#dados do índice para a equipa de fora e da casa e o número de golos marcado por cada
futebolData <- list(y1 = liga14_20$y_g1, y2=liga14_20$y_g2)

#valores iniciais para as variáveis
futebolInits <- list(home = -2, p1 = 0.7, p2 = 0.7, mu.att = 1, mu.def = 1, tau.att =  0.001, tau.def =  0.001, lambda1 = rep(5,306), lambda2 = rep(5,306), 
                     att.star = rep(0.4,18), def.star = rep(0.4,18))

futebolInits <- list(list(home = 0, p1 = 0, p2 = 0, mu.att = 0, mu.def = 0, tau.att = 1, tau.def = 1, lambda1 = rep(1,306),lambda2 = rep(1,306), 
                          att.star = rep(1,18), def.star = rep(1,18)),
                     list(home = 5, p1 = 0.2, p2 = 0.2, mu.att = -0.6, mu.def = -0.6, tau.att = 0.6, tau.def = 0.6, lambda1 = rep(2,306),lambda2 = rep(2,306), 
                          att.star = rep(0.2,18), def.star = rep(0.2,18)),
                     list(home = -2, p1 = 0.7, p2 = 0.7, mu.att = 1, mu.def = 1, tau.att =  0.001, tau.def =  0.001, lambda1 = rep(5,306),lambda2 = rep(5,306), 
                          att.star = rep(0.4,18), def.star = rep(0.4,18)))


# futebolInits <- list(home = 0, p1=0, p2=0, mu.att = 0, mu.def = 0, tau.att = 1, tau.def = 1, 
#                          att.star = rep(1,26), def.star = rep(1,26),
#                          home = 1, p1 = 0.5, p2 = 0.5,mu.att = 0.5, mu.def = 0.5, tau.att = 0.5,
#                          tau.def =  0.5, att.star = rep(0.5,26), def.star = rep(0.5,2216))

futebolMonitor <- c("lambda1","lambda2","p1","p2","att","home","def")


nimbleMCMC_fut<-nimbleMCMC(code = futebolCode, constants = futebolConsts, inits= futebolInits, data = futebolData, monitors = futebolMonitor, 
                           niter = 100000, nburnin = 50000, thin=10, nchains=3, WAIC=TRUE, samplesAsCodaMCMC = TRUE )
                     

